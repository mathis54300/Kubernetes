# Introduction à la virtualisation & à la conteneurisation

## Pourquoi la virtualisation est née

Historiquement, dans les entreprises (vers les années 2000-2010) on procédait de la sorte : on achetait un serveur (physique), on installait un système d’exploitation (ex. Windows Server ou Ubuntu Server) puis on y déployait une application (site web, base de données, etc.). 

Par exemple : « Nous allons acheter notre serveur DELL et installer Windows Server ou Ubuntu, ensuite nous mettons en ligne notre code du site web sur ce serveur… ensuite pour la base de données on rachetera un serveur… »

Résultat : beaucoup de serveurs physiques, chaque machine dédiée à une application => coûts élevés (matériel, énergie, emplacement), sous-utilisation des ressources.
La virtualisation est apparue pour répondre à ce besoin : sur une machine physique, à l’aide d’un hyperviseur, exécuter plusieurs machines virtuelles (VM) avec leur propre OS invité. Exemple cité : «…on peut créer deux Windows 10 à l’intérieur avec 4Go de RAM etc. » 

Ainsi on consolide les serveurs, on améliore l’utilisation des ressources, on gagne en flexibilité.

## Les limites de la virtualisation

Même si la virtualisation est utile, elle présente des inconvénients :

* Chaque VM embarque un système d’exploitation complet, avec drivers, OS invité, etc. Ceci consomme encore beaucoup de ressources. 

* Mise à jour, sécurité, gestion des OS invités = surcharge administrative.
* Pour des usages très dynamiques (micro-services, montée en charge rapide, densité élevée) la VM peut apparaître «lourde».
  L’article note : «…n’est-ce pas du gâchis d’installer tout un système d’exploitation … pour une application web, un micro service ou autre ?» 
  Donc, pour certains cas d’usage, la virtualisation atteint ses limites.

## La conteneurisation

### Qu’est-ce que c’est

La conteneurisation est l’étape suivante : plutôt que de faire tourner un OS complet par application, on s’appuie sur le système d’exploitation de l’hôte et on isole uniquement l’application + ses bibliothèques via un conteneur. L’article explique : «la conteneurisation … va s’appuyer du système d’exploitation original et juste émuler des librairies et autre pour isoler l’application tout en utilisant la couche système d’exploitation de l’hôte.» 

Le schéma est plus simple : on supprime deux couches (hyperviseur + OS invité) par rapport à la VM. 

### Pourquoi c’est «cool» pour les développeurs

Pour un développeur, la conteneurisation offre de nombreux bénéfices pratiques :

* **Portabilité** : Une fois que tu as défini ton conteneur (avec son image), tu peux l’exécuter sur ta machine locale, sur un serveur de test, en production… sans (ou presque) changement. Le fameux «ça fonctionne sur ma machine» se réduit.
* **Cohérence des environnements** : Le conteneur embarque les dépendances (bibliothèques, runtime, etc.). Le code fonctionne de la même façon quel que soit l’environnement. Cela réduit les bugs liés à des variations d’environnement.
* **Rapidité & légèreté** : Comparé à démarrer une VM, lancer un conteneur est beaucoup plus rapide. Moins de surcharge, plus de densité (plus de conteneurs sur un hôte).
* **Isolation applicative** : Chaque application ou micro-service peut tourner dans son conteneur, avec ses propres dépendances, sans interférer. Cela facilite les tests, les micro-services, les architectures modulaires.
* **Flux DevOps / CI/CD améliorés** : Le conteneur s’intègre bien aux chaînes d’intégration continue, automatisation, déploiement : construire, tester, déployer, mettre à l’échelle devient plus fluide.
* **Montée en charge & flexibilité** : Si tu dois servir rapidement beaucoup d’utilisateurs, tu peux déployer plusieurs instances d’un conteneur sans devoir provisionner une VM complète à chaque fois.
* **Meilleure utilisation des ressources** : En tant que dev, tu es souvent sur ta machine locale ou un serveur de test ; utiliser des conteneurs évite de sur-dimensionner, de configurer des VM lourdes, etc.


# Conclusion

La virtualisation est née d’un besoin concret : faire plus avec moins, consolider les serveurs, améliorer l’usage des ressources. L’article de Civilisation IT explique bien ce contexte et la transition vers la conteneurisation.

Pour un développeur, la conteneurisation est une révolution plus discrète que les VM mais très puissante : portabilité, cohérence, rapidité, isolation, intégration dans les pipelines DevOps…

Mais Docker est trop fragile pour de la production à moyenne/grande échelle.

https://civilisation-it.fr/tutoriels/docker/introduction
