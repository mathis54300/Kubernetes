# ğŸ›¡ï¸ SÃ©curitÃ©, RBAC et Secrets dans Kubernetes


## 1. Introduction

Kubernetes est une plateforme puissanteâ€¦ mais aussi une **porte dâ€™entrÃ©e critique** vers les applications et les donnÃ©es.
La sÃ©curitÃ© y est donc un pilier central : chaque ressource, chaque utilisateur, chaque composant doit Ãªtre contrÃ´lÃ©.

Le modÃ¨le de sÃ©curitÃ© de Kubernetes repose sur **trois niveaux complÃ©mentaires** :

1. **Authentification** â€” Qui es-tu ?
2. **Autorisation (RBAC)** â€” Que peux-tu faire ?
3. **SÃ©curisation des donnÃ©es (Secrets)** â€” Comment protÃ©ger ce que tu manipules ?

---

## 2. Authentification : sâ€™identifier auprÃ¨s de lâ€™API Server

Toutes les actions dans Kubernetes passent par le **kube-apiserver**.
Avant dâ€™exÃ©cuter une requÃªte, le serveur doit **identifier la source** :

* un utilisateur humain (via `kubectl`),
* un service interne (un pod),
* ou un composant systÃ¨me (kubelet, controllerâ€¦).

### ğŸ”‘ Les types dâ€™authentification

| MÃ©thode                          | Description                                                          |
| -------------------------------- | -------------------------------------------------------------------- |
| **Certificats X.509**            | MÃ©thode la plus courante pour les composants internes (ex. kubelet). |
| **Bearer Tokens / JWT**          | UtilisÃ©s par les comptes de service (`ServiceAccount`).              |
| **OpenID Connect (OIDC)**        | Permet dâ€™intÃ©grer un SSO dâ€™entreprise (Keycloak, Azure ADâ€¦).         |
| **Webhook Token Authentication** | DÃ©lÃ¨gue la vÃ©rification Ã  un service externe.                        |

> ğŸ’¡ Lâ€™API Server nâ€™accepte **aucune requÃªte anonyme** par dÃ©faut.

---

## 3. Autorisation : RBAC (Role-Based Access Control)

Une fois authentifiÃ©, un utilisateur nâ€™a pas encore tous les droits.
Câ€™est le rÃ´le du **RBAC** (Role-Based Access Control) de dÃ©finir **qui peut faire quoi, et sur quelles ressources.**

### ğŸ§© Le principe

RBAC repose sur **4 objets fondamentaux** :

| Ressource              | RÃ´le                                                    |
| ---------------------- | ------------------------------------------------------- |
| **Role**               | Ensemble de permissions au sein dâ€™un namespace.         |
| **ClusterRole**        | Ensemble de permissions globales (tous namespaces).     |
| **RoleBinding**        | Lie un Role Ã  un utilisateur/groupe dans un namespace.  |
| **ClusterRoleBinding** | Lie un ClusterRole Ã  un utilisateur/groupe globalement. |

---

### ğŸ”§ Exemple : autoriser un utilisateur Ã  lister les pods dans un namespace

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: dev
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-pods
  namespace: dev
subjects:
- kind: User
  name: alice
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

â†’ Ici, lâ€™utilisateur `alice` peut lire les pods du namespace `dev`, mais pas les modifier ni accÃ©der aux autres namespaces.

---

## 4. Modes dâ€™autorisation

Kubernetes supporte plusieurs **modes dâ€™autorisation**, dont RBAC est le plus courant.

| Mode                | Description                                                 |
| ------------------- | ----------------------------------------------------------- |
| **RBAC**            | BasÃ© sur les rÃ´les et les permissions (recommandÃ©).         |
| **ABAC**            | Ancien modÃ¨le basÃ© sur des fichiers de rÃ¨gles statiques.    |
| **Webhook**         | Externalise la logique dâ€™autorisation Ã  un service externe. |
| **Node Authorizer** | SpÃ©cifique pour les kubelets (communication entre nÅ“uds).   |

> âœ… En production, **RBAC** est la norme : flexible, dÃ©claratif et intÃ©grÃ© nativement.

---

## 5. Service Accounts : les identitÃ©s des pods

Les pods aussi doivent sâ€™authentifier auprÃ¨s de lâ€™API Kubernetes.
Ils le font via un **ServiceAccount** â€” un compte non humain dÃ©diÃ© aux workloads.

### Exemple :

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-sa
  namespace: prod
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-access
  namespace: prod
subjects:
- kind: ServiceAccount
  name: app-sa
  namespace: prod
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

Le pod utilisant `app-sa` pourra alors accÃ©der Ã  lâ€™API pour lire les pods (et rien dâ€™autre).
Chaque requÃªte est accompagnÃ©e dâ€™un **token JWT montÃ© dans le pod** Ã  `/var/run/secrets/kubernetes.io/serviceaccount/token`.

---

## 6. Les Secrets : protÃ©ger les donnÃ©es sensibles

Les **Secrets** sont des objets Kubernetes conÃ§us pour **stocker et distribuer des donnÃ©es confidentielles** :

* mots de passe,
* clÃ©s API,
* certificats TLS,
* tokens de service, etc.

### Exemple :

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
data:
  username: YWRtaW4=
  password: cGFzc3dvcmQ=
```

> âš ï¸ Les valeurs sont encodÃ©es en **Base64**, pas chiffrÃ©es.
> Il faut donc les protÃ©ger via des mÃ©canismes externes (KMS, etc.).

---

## 7. SÃ©curiser les Secrets

### ğŸ§± Bonnes pratiques :

* **Utiliser un gestionnaire externe** : AWS KMS, HashiCorp Vault, Azure Key Vault, etc.
* **Restreindre lâ€™accÃ¨s RBAC** : seuls les pods/services autorisÃ©s peuvent lire le secret.
* **Ã‰viter les montages en clair** : prÃ©fÃ©rer les *environment variables* temporaires ou le chiffrement au repos.
* **Activer le chiffrement des secrets dans etcd** :

  ```yaml
  encryptionConfig:
    resources:
    - resources: ["secrets"]
      providers:
      - aescbc:
          keys:
          - name: key1
            secret: <clÃ© base64>
      - identity: {}
  ```

---

## ğŸ”’ 8. SÃ©curitÃ© rÃ©seau et politique dâ€™isolation

MÃªme avec RBAC et Secrets, un pod pourrait parler Ã  un autre de maniÃ¨re indÃ©sirable.
Câ€™est lÃ  que les **NetworkPolicies** (vue prÃ©cÃ©demment) et **PodSecurityPolicies / Admission Controllers** entrent en jeu.

### ğŸ” Objectif :

* Restreindre la communication entre namespaces ou services sensibles.
* Ã‰viter quâ€™un conteneur sâ€™exÃ©cute en mode root.
* ContrÃ´ler les capacitÃ©s systÃ¨me (privileged, hostPath, etc.).

Exemple :

```yaml
apiVersion: policy/v1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  readOnlyRootFilesystem: true
  runAsUser:
    rule: MustRunAsNonRoot
```

> ğŸ§  Les **Pod Security Standards (PSS)** remplacent dÃ©sormais les anciennes PSP.
> Trois profils sont disponibles : *Privileged*, *Baseline*, *Restricted*.

---

## ğŸ§© 9. Admission Controllers

Avant quâ€™une ressource ne soit enregistrÃ©e dans etcd, elle passe par une **chaÃ®ne de contrÃ´leurs dâ€™admission** :

* Certains **valident** (ex. interdisent les pods sans labels),
* Dâ€™autres **mutent** (ajoutent des valeurs par dÃ©faut ou des sidecars).

Exemples :

* `NamespaceLifecycle` â€” empÃªche la crÃ©ation dans un namespace supprimÃ©.
* `ResourceQuota` â€” limite la consommation de ressources.
* `PodSecurity` â€” applique les rÃ¨gles PSS.

> ğŸ” Ces contrÃ´leurs renforcent la cohÃ©rence et la sÃ©curitÃ© globale du cluster.

---

## âœ… 10. RÃ©sumÃ©

| Domaine                    | Objectif                                | Composants clÃ©s                                    |
| -------------------------- | --------------------------------------- | -------------------------------------------------- |
| **Authentification**       | Identifier lâ€™entitÃ© (humain ou machine) | Certificats, Tokens, OIDC                          |
| **Autorisation (RBAC)**    | ContrÃ´ler les permissions               | Role, ClusterRole, RoleBinding, ClusterRoleBinding |
| **Service Accounts**       | Authentifier les pods                   | Tokens JWT automatiques                            |
| **Secrets**                | ProtÃ©ger les donnÃ©es sensibles          | Objet Secret, chiffrement, KMS                     |
| **SÃ©curitÃ© rÃ©seau & pods** | Isoler et contrÃ´ler les communications  | NetworkPolicy, PodSecurity, Admission Controllers  |

---

## ğŸ§  11. Ã€ retenir

* Kubernetes applique une **sÃ©curitÃ© Ã  plusieurs couches** (API, RBAC, rÃ©seau, donnÃ©es).
* Le **RBAC** est le cÅ“ur du contrÃ´le dâ€™accÃ¨s.
* Les **ServiceAccounts** sÃ©curisent les interactions des pods.
* Les **Secrets** doivent Ãªtre chiffrÃ©s et strictement contrÃ´lÃ©s.
* Et enfin, les **politiques rÃ©seau et dâ€™admission** renforcent la sÃ©curitÃ© Ã  lâ€™exÃ©cution.

> ğŸ›¡ï¸ Kubernetes nâ€™est pas sÃ©curisÃ© par hasard : câ€™est une architecture oÃ¹ **chaque ressource a une identitÃ©, un pÃ©rimÃ¨tre et des rÃ¨gles claires.**
